---
title: 自定义 ORM 框架
tags: 
    - mybatis
index_img: https://cdn.jsdelivr.net/gh/fengjian2705/cdn/img/mybatis/mybatis02.jpg
# excerpt: 持久层框架
---
## 需求

1. 根据用户 id 和 username 查询单个用户信息，查询参数 User

2. 查询用户列表，查询参数无

## JDBC

### 开发步骤（七步走）

> 载驱动 -> 获取连接 -> 定义 sql -> 获取预处理 statement并设置参数 -> 执行 sql -> 封装结果集 -> 释放资源

### 引入 mysql 驱动依赖

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.25</version>
</dependency>
```

### 代码实现

```java
/**
 * @作者 风间
 * @创建时间 2022/3/19 18:42
 */
package server;

import pojo.User;

import java.sql.*;

public class JDBCUtil {

    public static void main(String[] args) {

        // 数据库连接
        Connection connection = null;

        // 预处理 statement
        PreparedStatement preparedStatement = null;

        // 结果集
        ResultSet resultSet = null;

        try {
            // 加载驱动
            Class.forName("com.mysql.cj.jdbc.Driver");

            // 获取连接
            String url = "jdbc:mysql://127.0.0.1:3306/test?serverTimezone=GMT%2B8&characterEncoding=UTF-8";
            String username = "root";
            String password = "123456";
            connection = DriverManager.getConnection(url, username, password);

            // 获取预处理 statement
            String sql = "select * from user where id = ?";
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, 1);

            // 执行 sql
            resultSet = preparedStatement.executeQuery();

            // 遍历结果集封装到 User
            User user = null;
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String uname = resultSet.getString("username");
                user = User.builder()
                        .id(id)
                        .username(uname).build();
            }
            System.out.println(user);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            // 释放资源
            if (resultSet !=null) {
                try {
                    resultSet.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if (preparedStatement !=null) {
                try {
                    preparedStatement.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if (connection!=null) {
                try {
                    connection.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }


    }
}

```

**Tips**: mysql5 以上的 Driver 使用 `com.mysql.cj.jdbc.Driver` 而非 `com.mysql.jdbc.Driver`

### JDBC 方式的弊端

1. 数据库连接、释放频繁造成系统资源浪费，影响系统性能

2. sql 语句硬编码，维护不方便

3. sql 条件设置存在硬编码，维护不方便

4. 结果集封装存在硬编码（列名获取），维护不方便

### 优化方案

1. 数据库连接池的使用有效的避免了数据库连接的频繁创建与释放

2. 将 sql 统一编写在指定的 xml 文件中

3. 结果集的封装使用反射、内省等底层技术，自动将表字段与实体类属性映射

## 自定义持久层框架

> 一个持久层框架涉及框架端和框架的使用端

**使用端的工作：**

核心配置文件：

- sqlMapConfig.xml: 设置数据源并引入 mapper.xml 文件
  
- mapper.xml: sql 语句的编写

**框架端的工作：**

- 读取并解析使用端的配置文件

- 创建 SqlSessionFactory

- 创建 sqlSession 接口及实现类

### 新建使用端项目

#### 创建 sqlMapConfig.xml

```xml
<configuration>

    <!--配置数据源-->
    <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8"/>
    <property name="user" value="root"/>
    <property name="password" value="123456"/>


    <!--引入mapper文件-->
    <mapper resource="mapper.xml"/>

</configuration>

```

#### 创建 mapper.xml

```xml
<mapper namespace="User">

    <select id="selectOne" parameterType="pro.fengjian.pojo.User" resultType="pro.fengjian.pojo.User">
        select * from user where id = #{id} and username=#{username}
    </select>

    <select id="selectList" resultType="pro.fengjian.pojo.User">
        select * from user
    </select>
</mapper>
```

### 新建框架端项目

#### 引入依赖

```xml
<dependencies>

    <!-- mysql 驱动 -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.25</version>
    </dependency>

    <!-- 数据库连接池 -->
    <dependency>
        <groupId>c3p0</groupId>
        <artifactId>c3p0</artifactId>
        <version>0.9.1.1</version>
    </dependency>

    <!-- 日志相关 -->
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.17</version>
    </dependency>

    <!-- 单元测试 -->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>

    <!-- 解析 xml -->
    <dependency>
        <groupId>dom4j</groupId>
        <artifactId>dom4j</artifactId>
        <version>1.6.1</version>
    </dependency>

    <!-- xpath 语法 -->
    <dependency>
        <groupId>jaxen</groupId>
        <artifactId>jaxen</artifactId>
        <version>1.1.6</version>
    </dependency>

    <!-- 代码简略 -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.22</version>
    </dependency>
</dependencies>
```

#### 新建相关类来保存从使用端读取的配置文件信息

配置信息类：Configuration

```java
 /**
 * @作者 风间
 * @创建时间 2022/3/19 23:19
 */
package config;

import lombok.Data;

import java.util.HashMap;
import java.util.Map;

@Data
public class Configuration {

    // 数据源
    private DataSource dataSource;

    // map 集合
    private Map<String, MappedStatement> mappedStatementMap = new HashMap<>();

}

```

sql 映射类：MappedStatement

```java
/**
 * @作者 风间
 * @创建时间 2022/3/19 23:20
 */
package config;

import lombok.Data;

@Data
public class MappedStatement {

    // id
    private Integer id;
    
    // sql 语句
    private String sql;

    // 参数类型
    private Class<?> parameterType;

    // 返回值类型
    private Class<?> resultType;


}

```

#### 读取配置文件到流：

```java
/**
 * @作者 风间
 * @创建时间 2022/3/19 23:32
 */
package config;

import java.io.InputStream;

public class Resources {

    public static InputStream getResourcesAsStream(String path) {

        InputStream resourceAsStream = Resources.class.getClassLoader().getResourceAsStream(path);

        return resourceAsStream;
    }
}

```

#### 解析 sqlMapConfig.xml 文件封装到 Configuration 类

```java
/**
 * @作者 风间
 * @创建时间 2022/3/20 00:12
 */
package config;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import io.Resources;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import pojo.Configuration;

import java.beans.PropertyVetoException;
import java.io.InputStream;
import java.util.List;
import java.util.Properties;

public class XMLConfigureBuilder {

    private Configuration configuration;

    public XMLConfigureBuilder(Configuration configuration) {
        this.configuration = configuration;

    }

    public Configuration parseConfiguration(InputStream inputStream) throws DocumentException, PropertyVetoException {

        Document document = new SAXReader().read(inputStream);

        // <configuration>
        Element rootElement = document.getRootElement();
        List<Element> propertyElements = rootElement.selectNodes("//property");

        Properties properties = new Properties();
        for (Element propertyElement : propertyElements) {
            String name = propertyElement.attributeValue("name");
            String value = propertyElement.attributeValue("value");
            properties.put(name, value);
        }

        // 连接池
        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();
        comboPooledDataSource.setDriverClass(properties.getProperty("driverClass"));
        comboPooledDataSource.setJdbcUrl(properties.getProperty("jdbcUrl"));
        comboPooledDataSource.setUser(properties.getProperty("user"));
        comboPooledDataSource.setPassword(properties.getProperty("password"));

        // 填充 Configuration
        configuration.setDataSource(comboPooledDataSource);

        // mapper 部分
        List<Element> mapperElements = rootElement.selectNodes("//mapper");
        XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(configuration);
        for (Element mapperElement : mapperElements) {
            String mapperPath = mapperElement.attributeValue("resource");
            InputStream resourcesAsStream = Resources.getResourcesAsStream(mapperPath);
            xmlMapperBuilder.parse(resourcesAsStream);
        }
        return configuration;

    }
}

```

#### 解析 mapper.xml 文件 封装到 MappedStatement 和 Configuration

```java
/**
 * @作者 风间
 * @创建时间 2022/3/20 00:12
 */
package config;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import pojo.Configuration;
import pojo.MappedStatement;

import java.io.InputStream;
import java.util.List;

public class XMLMapperBuilder {

    private Configuration configuration;

    public XMLMapperBuilder(Configuration configuration) {
        this.configuration = configuration;
    }

    public void parse(InputStream inputStream) throws DocumentException, ClassNotFoundException {

        Document document = new SAXReader().read(inputStream);

        // <mapper>
        Element rootElement = document.getRootElement();

        String namespace = rootElement.attributeValue("namespace");

        List<Element> selectNodes = document.selectNodes("//select");
        for (Element element : selectNodes) {
            String id = element.attributeValue("id");// id 值
            String parameterType = element.attributeValue("parameterType");// 参数类型
            String resultType = element.attributeValue("resultType");// 返回值类型

            // 获取参数和返回值类型
            Class<?> parameterTypeClass = this.getClassType(parameterType);
            Class<?> resultTypeClass = this.getClassType(resultType);

            // statementId
            String statementId = namespace + "." + id;
            // sql
            String sql = element.getTextTrim();
            // 封装到 MappedStatement
            MappedStatement mappedStatement = new MappedStatement();
            mappedStatement.setId(id);
            mappedStatement.setParameterType(parameterTypeClass);
            mappedStatement.setResultType(resultTypeClass);
            mappedStatement.setSql(sql);
            // 填充 Configuration
            configuration.getMappedStatementMap().put(statementId,mappedStatement);
            

        }

    }

    private Class<?> getClassType(String className) throws ClassNotFoundException {
        return Class.forName(className);
    }
}

```

#### 构建者模式构建 SqlSessionFactory

```java
/**
 * @作者 风间
 * @创建时间 2022/3/19 23:34
 */
package sqlSession;

import config.XMLConfigureBuilder;
import org.dom4j.DocumentException;
import pojo.Configuration;

import java.beans.PropertyVetoException;
import java.io.InputStream;

public class SqlSessionFactoryBuilder {

    private Configuration configuration;

    public SqlSessionFactoryBuilder() {
        this.configuration = new Configuration();
    }

    public SqlSessionFactory build(InputStream inputStream) throws DocumentException, PropertyVetoException, ClassNotFoundException {

        // 1. 解析配置文件，封装到 Configuration
        XMLConfigureBuilder xmlConfigureBuilder = new XMLConfigureBuilder(configuration);
        Configuration configuration = xmlConfigureBuilder.parseConfiguration(inputStream);

        // 2. 创建 SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory(configuration);
        return sqlSessionFactory;
    }
}


```

#### sqlSessionFactory 开启 sqlSession

```java
/**
 * @作者 风间
 * @创建时间 2022/3/19 23:36
 */
package sqlSession;

import pojo.Configuration;

public class DefaultSqlSessionFactory implements SqlSessionFactory{

    private Configuration configuration;

    public DefaultSqlSessionFactory(Configuration configuration) {
    }


    @Override
    public SqlSession openSession() {
        return new DefaultSqlSession(configuration);
    }
}

```

#### sqlSession 编写 sql 方法

```java
/**
 * @作者 风间
 * @创建时间 2022/3/19 23:37
 */
package sqlSession;

import java.util.List;

public interface SqlSession {

    <E> List<E> selectList(String statementId, Object... param);

    <T> T selectOne(String statementId, Object... param);
}

```

#### defaultSqlSession

```java
/**
 * @作者 风间
 * @创建时间 2022/3/19 23:37
 */
package sqlSession;

import pojo.Configuration;
import pojo.MappedStatement;

import java.util.List;

public class DefaultSqlSession implements SqlSession {

    private Configuration configuration;

    public DefaultSqlSession(Configuration configuration) {
        this.configuration = configuration;
    }

    // 执行器对象
    private Executor simpleExecutor = new SimpleExecutor();


    @Override
    public <E> List<E> selectList(String statementId, Object... param) {
        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);
        return this.simpleExecutor.query(configuration, mappedStatement, param);
    }

    @Override
    public <T> T selectOne(String statementId, Object... param) {
        // 调用 selectList
        List<Object> objects = this.selectList(statementId, param);
        if (objects.size() == 1) {
            return (T) objects.get(0);
        } else {
            throw new RuntimeException("期望查询条数 1 条，但返回多条!");
        }
    }
}

```

#### Executor 执行器，实际 sql 操作类

```java
/**
 * @作者 风间
 * @创建时间 2022/3/19 23:37
 */
package sqlSession;

import pojo.BoundSql;
import pojo.Configuration;
import pojo.MappedStatement;
import utils.GenericTokenParser;
import utils.ParameterMapping;
import utils.ParameterMappingTokenHandler;

import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class SimpleExecutor implements Executor {

    private Connection connection;

    @Override
    public <E> List<E> query(Configuration configuration, MappedStatement mappedStatement, Object[] param) throws SQLException, NoSuchFieldException, IllegalAccessException, InstantiationException, IntrospectionException, InvocationTargetException {

        // 获取连接
        connection = configuration.getDataSource().getConnection();

        // 对 mapper 中的 sql 进行解析
        // 1. 将 #{xx} -> ?
        // 2. 封装参数列表 #{id} #{username} 中的 id username 等
        BoundSql boundSql = this.getBoundSql(mappedStatement.getSql());
        String finalSql = boundSql.getSqlText();

        // 设置 sql 参数，获取 preparedStatement
        PreparedStatement preparedStatement = connection.prepareStatement(finalSql);
        List<ParameterMapping> parameterMappingList = boundSql.getParameterMappingList();
        // 参数类型
        Class<?> parameterType = mappedStatement.getParameterType();
        for (int i = 0; i < parameterMappingList.size(); i++) {
            String name = parameterMappingList.get(i).getContent();
            Field declaredField = parameterType.getDeclaredField(name);
            declaredField.setAccessible(true);
            Object o = declaredField.get(param[0]);// 参数 user
            preparedStatement.setObject(i + 1, o);
        }

        // 执行 sql，封装结果集
        ResultSet resultSet = preparedStatement.executeQuery();
        Class<?> resultType = mappedStatement.getResultType();
        List<E> result = new ArrayList<>();

        while (resultSet.next()) {
            E e = (E) resultType.newInstance();
            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();
            for (int i = 1; i <= columnCount; i++) {
                // 属性名
                String columnName = metaData.getColumnName(i);
                // 属性值
                Object value = resultSet.getObject(columnName);
                // 创建属性描述器，为属性增加写读方法
                PropertyDescriptor propertyDescriptor = new PropertyDescriptor(columnName, resultType);
                // 获取写方法
                Method writeMethod = propertyDescriptor.getWriteMethod();
                // 写入值
                writeMethod.invoke(e, value);
            }
            result.add(e);
        }
        return result;
    }

    @Override
    public void close() {

    }

    private BoundSql getBoundSql(String sql) {
        // 标记处理类：主要配合通用标记解析器 GenericTokenParser 类完成对配置文件等的
        // 解析工作，其中 TokenHandler 主要完成处理
        ParameterMappingTokenHandler parameterMappingTokenHandler = new ParameterMappingTokenHandler();

        // GenericTokenParser：通用的标记解析器，完成了代码片段中占位符的解析，然后再根据
        // 给定的标记解析器（TokenHandler）进行表达式的处理
        // openToken closeToken handler
        GenericTokenParser genericTokenParser = new GenericTokenParser("#{", "}", parameterMappingTokenHandler);
        String parse = genericTokenParser.parse(sql);

        List<utils.ParameterMapping> parameterMappings = parameterMappingTokenHandler.getParameterMappings();
        return new BoundSql(parse,parameterMappings);
    }
}

```

Tips:
getDeclaredFiled 仅能获取类本身的属性成员（包括私有、共有、保护）
getField 仅能获取类(及其父类可以自己测试) public属性成员

#### 解析类

GenericTokenParser:

```java
/**
 *    Copyright 2009-2017 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package utils;

/**
 * @author Clinton Begin
 */
public class GenericTokenParser {

  private final String openToken; //开始标记
  private final String closeToken; //结束标记
  private final TokenHandler handler; //标记处理器

  public GenericTokenParser(String openToken, String closeToken, TokenHandler handler) {
    this.openToken = openToken;
    this.closeToken = closeToken;
    this.handler = handler;
  }

  /**
   * 解析${}和#{}
   * @param text
   * @return
   * 该方法主要实现了配置文件、脚本等片段中占位符的解析、处理工作，并返回最终需要的数据。
   * 其中，解析工作由该方法完成，处理工作是由处理器handler的handleToken()方法来实现
   */
  public String parse(String text) {
    // 验证参数问题，如果是null，就返回空字符串。
    if (text == null || text.isEmpty()) {
      return "";
    }

    // 下面继续验证是否包含开始标签，如果不包含，默认不是占位符，直接原样返回即可，否则继续执行。
    int start = text.indexOf(openToken, 0);
    if (start == -1) {
      return text;
    }

   // 把text转成字符数组src，并且定义默认偏移量offset=0、存储最终需要返回字符串的变量builder，
    // text变量中占位符对应的变量名expression。判断start是否大于-1(即text中是否存在openToken)，如果存在就执行下面代码
    char[] src = text.toCharArray();
    int offset = 0;
    final StringBuilder builder = new StringBuilder();
    StringBuilder expression = null;
    while (start > -1) {
     // 判断如果开始标记前如果有转义字符，就不作为openToken进行处理，否则继续处理
      if (start > 0 && src[start - 1] == '\\') {
        builder.append(src, offset, start - offset - 1).append(openToken);
        offset = start + openToken.length();
      } else {
        //重置expression变量，避免空指针或者老数据干扰。
        if (expression == null) {
          expression = new StringBuilder();
        } else {
          expression.setLength(0);
        }
        builder.append(src, offset, start - offset);
        offset = start + openToken.length();
        int end = text.indexOf(closeToken, offset);
        while (end > -1) {////存在结束标记时
          if (end > offset && src[end - 1] == '\\') {//如果结束标记前面有转义字符时
            // this close token is escaped. remove the backslash and continue.
            expression.append(src, offset, end - offset - 1).append(closeToken);
            offset = end + closeToken.length();
            end = text.indexOf(closeToken, offset);
          } else {//不存在转义字符，即需要作为参数进行处理
            expression.append(src, offset, end - offset);
            offset = end + closeToken.length();
            break;
          }
        }
        if (end == -1) {
          // close token was not found.
          builder.append(src, start, src.length - start);
          offset = src.length;
        } else {
          //首先根据参数的key（即expression）进行参数处理，返回?作为占位符
          builder.append(handler.handleToken(expression.toString()));
          offset = end + closeToken.length();
        }
      }
      start = text.indexOf(openToken, offset);
    }
    if (offset < src.length) {
      builder.append(src, offset, src.length - offset);
    }
    return builder.toString();
  }
}

```

ParameterMapping:

```java
package utils;

public class ParameterMapping {

    private String content;

    public ParameterMapping(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}

```java
package utils;

import java.util.ArrayList;
import java.util.List;




public class ParameterMappingTokenHandler implements TokenHandler {
	private List<ParameterMapping> parameterMappings = new ArrayList<ParameterMapping>();

	// context是参数名称 #{id} #{username}

	public String handleToken(String content) {
		parameterMappings.add(buildParameterMapping(content));
		return "?";
	}

	private ParameterMapping buildParameterMapping(String content) {
		ParameterMapping parameterMapping = new ParameterMapping(content);
		return parameterMapping;
	}

	public List<ParameterMapping> getParameterMappings() {
		return parameterMappings;
	}

	public void setParameterMappings(List<ParameterMapping> parameterMappings) {
		this.parameterMappings = parameterMappings;
	}

}


```

TokenHandler: 

```java
/**
 *    Copyright 2009-2015 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package utils;

/**
 * @author Clinton Begin
 */
public interface TokenHandler {
  String handleToken(String content);
}

```

### 测试

```java
import io.Resources;
import org.dom4j.DocumentException;
import org.junit.Test;
import pro.fengjian.User;
import sqlSession.SqlSession;
import sqlSession.SqlSessionFactory;
import sqlSession.SqlSessionFactoryBuilder;

import java.beans.IntrospectionException;
import java.beans.PropertyVetoException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;

/**
 * @作者 风间
 * @创建时间 2022/3/21 00:42
 */


public class IPersistenceTest {

    @Test
    public void testIPersistence() throws DocumentException, PropertyVetoException, ClassNotFoundException, IllegalAccessException, IntrospectionException, InstantiationException, SQLException, InvocationTargetException, NoSuchFieldException {

        InputStream inputStream = Resources.getResourcesAsStream("sqlMapConfig.xml");
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        SqlSession sqlSession = sqlSessionFactory.openSession();

        User user = User.builder().id(1).username("jack").build();
        user = sqlSession.selectOne("UserMapper.selectOne",user);
        System.out.println(user);
    }
}

```

### 使用代理模式优化

通过上面的定义框架，每次查询时还需要重复编写 statementId,比如 `UserMapper.selectOne`

优化，通过编写接口类，约定 statementId = 接口全路径 + 方法名

SqlSession 接口

```java
public <T> T getMappper(Class<?> mapperClass);
```

DefaultSqlSession 类

```java
@Override
public <T> T getMapper(Class<?> clazz) {

    Object proxyInstance = Proxy.newProxyInstance(
            clazz.getClassLoader(),
            new Class[]{clazz},
            (proxy, method, args) -> {
                // id: selectOne
                String methodName = method.getName();
                // namespace: className
                String className = method.getDeclaringClass().getName();
                // statementId
                String statementId = className + "." + methodName;

                return this.selectOne(statementId, args);
            });
    return (T) proxyInstance;
}
```

测试

```java
@Test
public void testIPersistence() throws DocumentException, PropertyVetoException, ClassNotFoundException, IllegalAccessException, IntrospectionException, InstantiationException, SQLException, InvocationTargetException, NoSuchFieldException {

    InputStream inputStream = Resources.getResourcesAsStream("sqlMapConfig.xml");
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    SqlSession sqlSession = sqlSessionFactory.openSession();

    User user = User.builder()
            .id(1)
            .username("jack")
            .build();
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    user = userMapper.selectOne(user);
    System.out.println(user);
}
```

__完__